#!/usr/bin/env python3

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import argparse
import sys

def main():
    parser = argparse.ArgumentParser(description='Analyze AprilTag Accuracy from CSV data.')
    parser.add_argument('file', type=str, help='Path to the CSV file generated by accuracy_investigation node')
    args = parser.parse_args()

    try:
        df = pd.read_csv(args.file)
    except FileNotFoundError:
        print(f"Error: File '{args.file}' not found.")
        sys.exit(1)
    except Exception as e:
        print(f"Error reading file: {e}")
        sys.exit(1)

    # Need at least one row
    if df.empty:
        print("Error: CSV file is empty.")
        sys.exit(1)

    print(f"Loaded {len(df)} samples from {args.file}")

    # Extract columns
    t = df['time'].values
    vicon = df[['vicon_x', 'vicon_y', 'vicon_z']].values
    cam = df[['cam_x', 'cam_y', 'cam_z']].values

    # 1. Alignment at t=0
    # Assumption: At t=0, the error is 0 (relative measurement).
    # We subtract the initial position from all subsequent positions for both trajectories.
    # This effectively aligns their starting points.
    
    vicon_start = vicon[0]
    cam_start = cam[0]

    vicon_rel = vicon - vicon_start
    cam_rel = cam - cam_start

    # 2. Compute Error
    # Error vector at each step
    error_vec = vicon_rel - cam_rel
    # Euclidean distance error
    error_norm = np.linalg.norm(error_vec, axis=1)

    # 3. Compute Distance (Depth)
    # Using Vicon Z as the "ground truth" depth, assuming Z is forward in the test setup.
    # If the user moved in X/Y, we can use norm of vicon_rel as distance.
    # Let's use Euclidean distance from start as the "Distance" metric.
    distance_from_start = np.linalg.norm(vicon_rel, axis=1)

    # Statistics
    print(f"Mean Error: {np.mean(error_norm):.4f} m")
    print(f"Max Error:  {np.max(error_norm):.4f} m")
    print(f"Std Dev:    {np.std(error_norm):.4f} m")

    # 4. Visualization
    fig = plt.figure(figsize=(15, 10))

    # Plot 1: Error over Time
    ax1 = fig.add_subplot(2, 2, 1)
    ax1.plot(t, error_norm, label='Euclidean Error', color='r')
    ax1.set_title('Error over Time')
    ax1.set_xlabel('Time [s]')
    ax1.set_ylabel('Error [m]')
    ax1.grid(True)
    ax1.legend()

    # Plot 2: Error vs Distance from Start
    ax2 = fig.add_subplot(2, 2, 2)
    ax2.scatter(distance_from_start, error_norm, alpha=0.5, c='b', s=10)
    ax2.set_title('Error vs. Distance from Start')
    ax2.set_xlabel('Distance Traveled [m]')
    ax2.set_ylabel('Error [m]')
    ax2.grid(True)

    # Plot 3: 3D Trajectory Comparison (Top Down / 2D projection usually better)
    # Let's align them to start at 0,0 for visualization
    ax3 = fig.add_subplot(2, 2, 3)
    ax3.plot(vicon_rel[:, 0], vicon_rel[:, 1], label='Vicon (Truth)', color='g', linestyle='--')
    ax3.plot(cam_rel[:, 0], cam_rel[:, 1], label='Camera (Measured)', color='m', linestyle='-')
    ax3.set_title('Trajectory (XY Plane - Relative)')
    ax3.set_xlabel('X [m]')
    ax3.set_ylabel('Y [m]')
    ax3.legend()
    ax3.grid(True)
    ax3.axis('equal')

    # Plot 4: Error Heatmap in Camera Frame (Experimental)
    # We use the raw Camera X/Y to see WHERE in the image/frame the tag was.
    # Assuming cam_x and cam_y from the CSV roughly correspond to lateral positions in camera frame.
    ax4 = fig.add_subplot(2, 2, 4)
    sc = ax4.scatter(cam[:, 0], cam[:, 1], c=error_norm, cmap='jet', s=20)
    ax4.set_title('Error Distribution in Camera Frame (X/Y)')
    ax4.set_xlabel('Camera X [m]')
    ax4.set_ylabel('Camera Y [m]')
    plt.colorbar(sc, ax=ax4, label='Error [m]')
    ax4.grid(True)
    
    plt.tight_layout()
    plt.show()

if __name__ == '__main__':
    main()
